\documentclass[10pt,conference,compsocconf]{IEEEtran}

\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{blindtext, amsmath, comment, subfig}
\usepackage{grffile}
\usepackage{caption}
%\usepackage{subcaption}
%\usepackage{algorithmic}
\usepackage[utf8]{inputenc}


\title{CS-523 SecretStroll Report}
\author{Author 1, Author 2}
\date{April 2020}

\begin{document}

\maketitle

\begin{abstract}
    SecretStroll is a privacy preserving LBS. SecretStroll is build on top of 3 core modules: an Anonymous
    \textit{Attribute-based Credential protocol} for authorization, <part 2> and <part 3>.
\end{abstract}

\section{Introduction}
SecretStroll is a Location Based System (LBS), which aims to provide users with information about Points of Interest (POI)
near their location, satisfying user-specified criteria (i.e retrieve POIs near user location which correspond to the description
of "restaurant").\newline
LBS are prone to be privacy-sensitive system: if not implemented following a \textit{Privacy by Design} paradigm, they can leak
many information about users, such as their location and movement patterns, which can lead to more privacy-disruptive disclosure attacks.
For this reason, we designed SecretStroll by identifying layers at which the system could potentially leak information and implementing
privacy-preserving mechanism at each layer.\newline
SecretStroll is formed by 3 core layers: an \textit{Attribute-based Credential} protocol, <part2> and <part3>.
\subsection{Attribute-based credential}
SecretStroll exploits an Attribute-based credential Protocol to authorize users to fetch POIs of a given type, for which they must have subscribed to.
At issuing time, users will provide their username together to a set subscriptions (i.e types of POIs) which are currently supported
by SecretStroll system. SecretStroll server will verify the validity of user's request and generate a valid credential for the specified
subscriptions and username. Users will later show their credentials together with a subset of their subscriptions: in this step,
the \textit{Showing protocol}, users will have to prove to the server to have a valid credential over their attributes
(including, but not limited to, their subscriptions). Users will also use their credential to perform a digital signature
on their current location. If the proof suceeds, the server will reply with a list of POIs matching the types requested by the user.
\subsection{part 2}
\subsection{part 3}
\section{Attribute-based credential}
For the implementation of the authorization through \textit{Attribute-based credentials}, we have carefully followed the protocol
described by \textit{Pointcheval and Sanders} \cite{PS_signature}.
Nevertheless, during the development of the \textit{ABC} system, some design challenges needed to be solve, and it is worth highlighting their solution:
\begin{itemize}
    \item \textbf{Server-Client agreement on the attribute domain}: as described in \cite{PS_signature}, before even starting the protocol,
    server and client must agree on the public parameters, including the number $L$ of possible attributes. Moreover, users should choose
    attributes (subscriptions) which are recognized by the server. To this end, we decided to embed the list of available subscriptions
    in the server public key (which follows the description of the paper). The 'attribute domain' is thus formed by the $L-2$ possible
    subscriptions, followed by the username and, following a common approach in designing \textit{ABC} protocols, a client secret key.
    Clients are expected to choose their subscriptions from the provided set.
    \item \textbf{Attribute encoding}: once we designed the server-client agreement in such a way that each parameter of the public key
    (namely $Y_i$ and $\tilde{Y}_{i}$) was mapped to one attribute, we decided to encode attributes in the following way:
    if the user decides to subscribe to service $i$, then the exponent of parameter $i$ of server public key(i.e the attribute),
     will be a fixed prime number in $Z_p$ (where $p$ is the order of the prime groups defined in the paper),
    to which we refer as \texttt{SUBSCRIBED\_YES}. Conversely, any service to which the client does not subscribe,
    will be encoded with a different fixed prime, \texttt{SUBSCRIBED\_NO}. The 'username' attribute will be encoded through
    \texttt{int.from\_bytes(username.encode(), 'big')} method available in \texttt{python}. Client secret key will be a
    random number in $Z_p$.
    \item \textbf{Fiat-Shamir Heuristic for Issuance Request}: the \textit{Issuance Protocol} once again follow thoroughly the paper description.
    Client will choose their \textit{user-defined} attributes, which in our implementation will simply be its secret key,
    togheter with a blinding factor $t$. Note that the random blinding factor guarantees \textit{issuer unlinkability}. User commitment $C$ will thus be $g^{t}*Y_{L}^{client\_sk}$. Client will also produce a
    \textit{Non Interactive Zero Knowledge Proof of Knowledge} of his commitment. In order to generate the challenge in a
    non interactive way, we applied \textit{Fiat-Shamir Heuristic} to the \textit{sigma protocol} defined for the
    \textit{Pedersen's Commitment PK}: the provided challenge was the \textit{sha256} digest of the public parameters
    (the commitment $C$, the randomness $R$ of the proof, and the public key parameters used for exponentiation, $g$ and $Y_{L}^{client\_sk}$)
    \item \textbf{Fiat-Shamir Heuristic for linking Disclosure Proof to location}: \textit{Fiat Shamir Heuristic} plays also a crucial role when
    linking the \textit{Showing protocol} of the paper to a specific message (i.e client's current location). This prevents a malicious user
    eavesdropping communication to steal one user's credential in order to gain access to the service from its current location.
    In order to apply \textit{Fiat-Shamir Heuristic}, we modelled the \textit{Disclosure Proof} as a regular \textit{NIZKP} on a Pedersen's Commitment,
    where generators belong to the $G_T$ group.\newline
    In this specific setting, the user commitment is: \[C=e(\sigma_{1}^{`}, \tilde{g})^t\prod_{i \in H}e(\tilde{Y}_{i}^{a_i},\tilde{g})\]Thus,
    the generators in the Proof of Knowledge are $e(\sigma_{1}^{`}, \tilde{g})$ and $e(\tilde{Y}_{i}^{a_i},\tilde{g})$.
    In order to link the location to the proof, we used a \textit{Schnorr's Signature}, producing the challenge as:
    \[c = sha256(R|C|public\_parameters|location)\]
    The server validations follows two steps: first, it checks it can recompute client's commitment via the \textit{bilinear} property of the pairing:
    \[C = e(\sigma_2^`,\tilde{g})\prod_{i \in D}e(\sigma_1^`,\tilde{Y}_i)^{-a_i}e(\sigma_1^`,\tilde{X})^{-1}\]
    Secondly, it checks the validity of the proof on client's commitment. Also, it is worth noticing that the \textit{ABC} protocol fulfills both selective disclosure and, thanks to the randomization of the signature $\sigma$, verifier unlinkability.
\end{itemize}
\subsection{Test}
In order to test the correctness of our \textit{ABC protocol}, we implemented a simple test suite using \texttt{pytest} called \texttt{test\_abc.py},
involving a correct run of the protocol and 4 runs where the client deviate from the protocol in different ways:
\begin{itemize}
    \item \texttt{test\_registering\_invalid\_attributes}: client issues a request with an attribute which do not belong to the agreed domain.
    \item \texttt{test\_requesting\_service\_not\_subscribed}: client tries to request a service to which it did not subscribe.
    Implicitly, this will lead to a \textit{Disclosure Proof} which is not valid for the given credentials.
    \item \texttt{test\_invalid\_signature\_on\_message}: simulates the tentative of a passive adversary to ask for a given service, from its current
    location, by replaying the \textit{Disclosure Proof} sent by a client from a different location.
    \item \texttt{test\_invalid\_user\_commitment}: when creating the issue request, client presents a proof which is not valid for his commitment.
\end{itemize}

\subsection{Evaluation}
For the evaluation of the \textit{ABC protocol}, we analyzed how the communication cost in terms of exchanged bytes, and the
computational cost in terms of runtime, variate in respect to the number of available subscriptions (attributes). The analysis has
been repeated seperatelly for each of the steps:
\begin{itemize}
    \item \textbf{Key Generation}
    \item \textbf{Issuance phase}
    \item \textbf{Showing phase - verification of proof}
    \item \textbf{Showing phase - generation of proof}
\end{itemize}
    \begin{figure}[t]
\centerline{\includegraphics[scale=0.3]{dataflow_keygen}}
\label{fig1}
\end{figure}
    \begin{figure}[t]
\centerline{\includegraphics[scale=0.3]{runtime_keygen}}
\label{fig2}
\end{figure}
    \begin{figure}[t]
\centerline{\includegraphics[scale=0.3]{dataflow_issuance}}
\label{fig3}
\end{figure}
    \begin{figure}[t]
\centerline{\includegraphics[scale=0.3]{runtime_issuance}}
\label{fig4}
\end{figure}
    \begin{figure}[t]
\centerline{\includegraphics[scale=0.3]{dataflow_showing}}
\label{fig5}
\end{figure}
    \begin{figure}[t]
\centerline{\includegraphics[scale=0.3]{runtime_showing}}
\label{fig6}
\end{figure}
    \begin{figure}[t]
\centerline{\includegraphics[scale=0.3]{runtime_verification}}
\label{fig7}
\end{figure}


\section{(De)Anonymization of User Trajectories}

\subsection{Privacy Evaluation}
Provide a privacy analysis of the dataset. You should explicitly state your assumptions, adversary
models, methods, and findings.

\subsection{Defences}
Propose a defence that users of the service could deploy to protect their privacy.  You
should state your assumptions, adversary models, and provide an experimental evaluation of your
defences using the datasets and the grid specification. You should also discuss the
privacy-utility trade-offs of your defence.

\section{Cell Fingerprinting via Network Traffic Analysis}

\subsection{Implementation details}
Provide a description of your implementation here. You should provide details on your data collection methods, feature extraction, and classifier training.

\subsection{Evaluation}
Provide an evaluation of your classifier here -- the metrics after 10-fold cross validation.

\subsection{Discussion and Countermeasures}
Comment on your findings here. How well did your classifier perform? What factors could influence its performance? Are there countermeasures against this kind of attack?

\bibliographystyle{IEEEtran}
\bibliography{bib}
\end{document}
